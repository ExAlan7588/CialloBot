;--------------------------------------------
;IFRAND CODED BY 唤く
;乱数を生成する函数。与えた条件に応じて返还される乱数の范围を切り替えられる
;あと负数を返させることもできる
;「メッセージをRANDで分岐させたいが、キャラが特定の素質を持っている场合この分岐だけ弹きたい」みたいなときに使える

;返还する值は10000通りまでいける。增やしたければRANDARRAYを增やすこと

;VARSTR:0-5	生成する值をコンマ区切りで指定する。
;			要素1つにつき1000个まで指定子が入る
;			含まれる值が返还候补となるには、对応するCONDITIONが真である必要がある
;			なお、返还候补の值が被っていた场合、单纯に二重に入る（その值の选择される概率が倍になる）

;指定子の书き方
;方法①：A, B, C...	单纯な追加。返还候补にAとBとCが入る
;方法②：ATOB, ....	单纯な返还候补にAからBまでの连续した值が入る
;					なおA<Bである必要はない
;方法③：D1, D2...	指定した值を、返还候补から除外する
;					削除处理は各VARSTRの处理が行われた后、返还直前に行われる
;					したがって、VARSTR:0で除外指定をしたのちVARSTR:1で追加指定をしても、その值は返还候补とならない
;					同じ值が复数返还候补に含まれている场合も同样である
;方法④：D1TO10...	削除指定でもTOでの指定が使える。

;CONDITION:0-5	真伪值。真だった场合、对応するVARSTRを返还候补に含める
;				たとえば「LOCAL:0番のキャラが巨乳のときだけ、VARSTR:1に与えた值を返还候补に含めたい」なら、
;				CONDITION:1にTALENT:(LOCAL:0):巨乳 == 1 を与えればよい

;用例
;LOCAL:0 = IFRAND("0TO5, 7", 1, "6TO10", TALENT:(ARG:0):仮性包茎, "D1, D7, D8", TALENT:(ARG:0):爆乳)
;LOCAL:0に0-5,7のいずれかを代入。ARG:0のキャラが仮性包茎なら6-10も候补に含まれるため、0-10(7だけ概率倍)となる。ただし、ARG:0のキャラが爆乳なら1と7と8は代入させない。

;注意点
;最终的に返すべき值がない场合や、指定子の书き方が不正である场合、エラーを吐いて落ちる。
;---------------------------------------------
@IFRAND(VALSTR:0, CONDITION:0, VALSTR:1 = "", CONDITION:1 = 0, VALSTR:2 = "" , CONDITION:2 = 0, VALSTR:3 = "", CONDITION:3 = 0, VALSTR:4 = "", CONDITION:4 = 0, VALSTR:5 = "", CONDITION:5 = 0, VALSTR:6 = "", CONDITION:6 = 0, VALSTR:7 = "", CONDITION:7 = 0, VALSTR:8 = "", CONDITION:8 = 0, VALSTR:9 = "", CONDITION:9 = 0, VALSTR:10 = "", CONDITION:10 = 0, VALSTR:11 = "", CONDITION:11 = 0, VALSTR:12 = "", CONDITION:12 = 0, VALSTR:13 = "", CONDITION:13 = 0, VALSTR:14 = "", CONDITION:14 = 0, VALSTR:15 = "", CONDITION:15 = 0, VALSTR:16 = "", CONDITION:16 = 0, VALSTR:17 = "", CONDITION:17 = 0, VALSTR:18 = "", CONDITION:18 = 0, VALSTR:19 = "", CONDITION:19 = 0)
#FUNCTION
;值指定文字列
#DIMS VALSTR, 20
;值指定が有效か　呼び出し侧で真伪判定ぶっこんでください（对象が巨乳か？　とか）
#DIM CONDITION, 20
;コンマでSPLITされた后の值指定
#DIMS SPLIT_VALSTR, 1000
;值指定の分割数
#DIM SPLIT_VALSTR_NUM
;今见ている值指定
#DIMS THIS_VALSTR
;值指定で范围指定を利用した时用
#DIMS RANGESTR, 2
#DIM RANGE, 2
;最终的に生成される乱数を格纳する配列
#DIM RANDARRAY, 10000
;最终的に生成される乱数の候补数
#DIM RAND_NUM
;削除する值を格纳する配列
#DIM DELETEARRAY, 10000
;削除する值の
#DIM DELETE_NUM
;RESULT保存用(污染するため)
#DIM SAVED_RESULT

VARSET RANDARRAY
VARSET RAND_NUM
VARSET DELETEARRAY
VARSET DELETE_NUM

SAVED_RESULT = RESULT

FOR LOCAL, 0, VARSIZE("CONDITION")

	;真伪判定が伪であればその值指定を无视する
	SIF !CONDITION:LOCAL
		CONTINUE

	;值指定を分割する
	SPLIT VALSTR:LOCAL, "," , SPLIT_VALSTR
	SPLIT_VALSTR_NUM = RESULT

	FOR LOCAL:1, 0, SPLIT_VALSTR_NUM
		;スペースを除去
		THIS_VALSTR = %SPLIT_VALSTR:(LOCAL:1)%
		THIS_VALSTR = %REPLACE(THIS_VALSTR, "　", "")%
		THIS_VALSTR = %REPLACE(THIS_VALSTR, " ", "")%

		;空文字列になったら无视
		SIF THIS_VALSTR == ""
			CONTINUE

		;消去指定を利用している场合
		IF STRFIND(THIS_VALSTR, "D") == 0
			THIS_VALSTR = %SUBSTRING(THIS_VALSTR, 1)%
			;消去指定で范围指定
			IF STRFIND(THIS_VALSTR, "TO") != -1
				;ATOBを「值Aと值B」にしてRANGEに格纳
				SPLIT THIS_VALSTR, "TO", RANGESTR
				SIF !ISNUMERIC(RANGESTR:0) || !ISNUMERIC(RANGESTR:1)
					THROW 削除范围指定に不正な值が含まれています %THIS_VALSTR%
				RANGE:0 = TOINT(RANGESTR:0)
				RANGE:1 = TOINT(RANGESTR:1)
				;ATOBをDELETEARRAYに格纳
				FOR LOCAL:2, MIN(RANGE:0, RANGE:1), MAX(RANGE:0, RANGE:1) + 1
					DELETEARRAY:DELETE_NUM = LOCAL:2
					DELETE_NUM ++
				NEXT
			;消去指定の单一值指定
			ELSE
				SIF !ISNUMERIC(THIS_VALSTR)
					THROW 削除值指定に不正な值が含まれています %THIS_VALSTR%
				DELETEARRAY:DELETE_NUM = TOINT(THIS_VALSTR)
				DELETE_NUM ++
			ENDIF

		;范围指定を利用している场合
		ELSEIF STRFIND(THIS_VALSTR, "TO") != -1
			;A-Bを「值Aと值B」にしてRANGEに格纳
			SPLIT THIS_VALSTR, "TO", RANGESTR
			SIF !ISNUMERIC(RANGESTR:0) || !ISNUMERIC(RANGESTR:1)
				THROW 范围指定に不正な值が含まれています %THIS_VALSTR%
			RANGE:0 = TOINT(RANGESTR:0)
			RANGE:1 = TOINT(RANGESTR:1)
			;ATOBをRANDARRAYに格纳
			FOR LOCAL:2, MIN(RANGE:0, RANGE:1), MAX(RANGE:0, RANGE:1) + 1
				RANDARRAY:RAND_NUM = LOCAL:2
				RAND_NUM ++
			NEXT

		;单一の值である场合
		ELSE
			SIF !ISNUMERIC(THIS_VALSTR)
				THROW 值指定に不正な值が含まれています %THIS_VALSTR%
			RANDARRAY:RAND_NUM = TOINT(THIS_VALSTR)
			RAND_NUM ++
		ENDIF
	NEXT
NEXT


FOR LOCAL, 0, DELETE_NUM
	WHILE FINDELEMENT(RANDARRAY, DELETEARRAY:LOCAL, 0, RAND_NUM) != -1
		LOCAL:1 = FINDELEMENT(RANDARRAY, DELETEARRAY:LOCAL, 0, RAND_NUM)
;		PRINTFORML {DELETEARRAY:LOCAL} {LOCAL:1}, 
		IF LOCAL:1 == VARSIZE("RANDARRAY") - 1
			RANDARRAY:(LOCAL:1) = 0
		ELSE
			;こいつなんか第二参数の正负で挙动违うんだけど
			ARRAYSHIFT RANDARRAY, -1, 0, LOCAL:1
		ENDIF
		RAND_NUM -= 1
	WEND
NEXT

SIF RAND_NUM == 0
	THROW IFRANDの返还候补值が一つもありません

;污染されたRESULTを元に戻す
RESULT = SAVED_RESULT

RETURNF RANDARRAY:(RAND:RAND_NUM)
