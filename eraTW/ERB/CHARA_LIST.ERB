;泛用・角色列表作成函数
;条件についてはCHECK_CHARA函数を参照
;条件に合致する角色の列表を作成する
@MAKE_CHARA_LIST(LIST_TYPE, L_ID, CHARA_LIST, CHARA_CNT)
#LOCALSIZE 1
#LOCALSSIZE 1
#DIMS LIST_TYPE
#DIM C_ID
#DIM REF L_ID       ;列表のクラスID
#DIM REF CHARA_LIST ;角色一览
#DIM REF CHARA_CNT  ;角色カウンタ
VARSET CHARA_LIST
VARSET CHARA_CNT
L_ID = OBJNAME_TO_ID(0, "GET", "角色列表", LIST_TYPE)
SIF FLAG:排序
	CALL CHARASORT_EX
IF L_ID == -1
	FOR LOCAL, 0, EX_CHARANUM
		IF FLAG:排序
			C_ID = RESULT:LOCAL
			SIF C_ID < 0
				CONTINUE
		ELSE
			C_ID = LOCAL
			SIF C_ID >= CHARANUM
				BREAK
		ENDIF
		SIF !CHECK_CHARA(C_ID, LIST_TYPE)
			CONTINUE
		CHARA_LIST:CHARA_CNT = C_ID
		CHARA_CNT ++
	NEXT
ELSE
	FOR LOCAL, 0, EX_CHARANUM
		IF FLAG:排序
			C_ID = RESULT:LOCAL
			SIF C_ID < 0
				CONTINUE
		ELSE
			C_ID = LOCAL
			SIF C_ID >= CHARANUM
				BREAK
		ENDIF
		SIF !GET_INT(C_ID, "角色列表", L_ID, "判定")
			CONTINUE
		CHARA_LIST:CHARA_CNT = C_ID
		CHARA_CNT ++
	NEXT
ENDIF
; PRINTFORMW CHARA_CNT{CHARA_CNT}



;@SHOW_CHARA_LISTが机能盛りすぎて使いにくくなったので朴素的やつも
;配列に收められている数值の角色をずらっと无造作にボタンとして表示するだけ
;先に角色列表作ってないとつかえません
;列表に无い数值は弹き、999は中止扱いです
@SIMPLE_CHARA_LIST(CHARA_LIST, CHARA_CNT, OP)
#DIM  REF CHARA_LIST ;列表本体、登录番号にて记录
#DIM  REF CHARA_CNT  ;列表に该当した角色の数
#DIMS OP
FOR LOCAL, 0, CHARA_CNT
	PRINTFORML [{LOCAL, 3}] - %NAME_OUTPUT_TRANSLATION("CALLNAME", (CHARA_LIST:LOCAL))%
NEXT
PRINTFORML 
PRINTFORML [999] - 返回
DO
	INPUT
	SELECTCASE RESULT
	CASE 999
		RETURN 999
	CASEELSE
		SIF INRANGE(RESULT, 0, CHARA_CNT - 1)
			RETURN RESULT
		REUSELASTLINE 无效输入
		CONTINUE
	ENDSELECT
LOOP 1



;列表ソート函数
;对象配列变量を登录番号の罗列とみ无てINPUT_STRの内容に応じてSORTしなおす
;参数は全て必须
;ソート自体はともかく其他の制御部分がやや复杂化したか
;ソートアルゴリズムはwikipediaからコピペってみたノームソート
;1万件とかのデータ使用わけで无朴素的のでいいんじゃね？
;INPUT_STRに使える文字列は「DISP_MEMO:X＋（降顺or升顺）」
;DISP_MEMOで名前冲突を起こすとバグるので追加の际は注意
;具体的には"时奸"は刻印ということにしているので経験用に追加しても使えない
;DISP_MEMOを变更するなら@CHARA_BUTTON,@SHOW_CHARA_LISTも变更の必要があるので注意
@SORT_LIST(INPUT_STR, CHARA_LIST, CHARA_CNT)
#DIMS     INPUT_STR  ;ソート内容の指示
#DIM      MEMO_TYPE  ;今回のソート项目、CSVでの要素数
#DIMS     CHECK_VAR  ;チェック对象となる变量名
#DIMS     CHECK_TYPE ;比较演算子の种类
#DIM      NUM_LOOP   ;ループ回数
#DIM  REF CHARA_LIST ;角色列表の内容配列
#DIM      CHARA_CNT  ;列表に含まれる角色数
;ソート项目の种别
{
#DIMS CONST DISP_MEMO , 25 = 
	"体力", "气力", 
	"Ｃ感", "Ｖ感", "Ａ感", "Ｂ感", "Ｍ感", 
	"亲密", "顺从", "欲望", "技巧", 
	"指技", "舌技", "胸技", "腰技", "膣技", "Ａ技", 
	"苦痛", "快乐", "屈服", "反抗", "时奸", 
	"好感", "信赖", "欲求"
}
;ソート项目の各角色变量における位置
{
#DIM CONST MEMO_ID , 25 = 
	 0,  1, 
	 0,  1,  2,  3,  4, 
	 9, 10, 11, 12, 
	50, 51, 52, 53, 54, 55, 
	 0,  1,  2,  3,  5, 
	 2,  4,340
}
;ソート项目の検索
MEMO_TYPE = 0
NUM_LOOP = VARSIZE("DISP_MEMO")
FOR LOCAL, 0, NUM_LOOP
	IF STRCOUNT(INPUT_STR, DISP_MEMO:LOCAL)
		MEMO_TYPE = LOCAL
		BREAK
	ENDIF
	SIF LOCAL == NUM_LOOP - 1
		THROW 错误的INPUT_STR　%INPUT_STR%
NEXT

SELECTCASE DISP_MEMO:MEMO_TYPE
CASE "体力", "气力"
	CHECK_VAR '= "BASE"
CASE "Ｃ感", "Ｖ感", "Ａ感", "Ｂ感", "Ｍ感", "亲密", "顺从", "欲望", "技巧"
	CHECK_VAR '= "ABL"
CASE "指技", "舌技", "胸技", "腰技", "膣技", "Ａ技", 
	CHECK_VAR '= "ABL"
CASE "苦痛", "快乐", "屈服", "反抗", "时奸", 
	CHECK_VAR '= "MARK"
CASE "好感", "信赖", "欲求"
	CHECK_VAR '= "CFLAG"
CASEELSE
	THROW 错误的DISP_MEMO:MEMO_TYPE %DISP_MEMO:MEMO_TYPE%、MEMO_TYPE {MEMO_TYPE}
ENDSELECT

IF STRCOUNT(INPUT_STR, "降顺")
	CHECK_TYPE '= ">="
ELSEIF STRCOUNT(INPUT_STR, "升顺")
	CHECK_TYPE '= "<="
ELSE
	THROW 错误的INPUT_STR %INPUT_STR%
ENDIF

;ソート实处理
LOCAL:0 = 1
WHILE LOCAL:0 < CHARA_CNT
	SIF !(LOCAL:0)
		LOCAL:0 ++
	IF CHARA_COMPARE(CHECK_VAR, MEMO_ID:MEMO_TYPE, CHARA_LIST:(LOCAL:0 - 1), CHECK_TYPE, CHARA_LIST:(LOCAL:0))
		LOCAL:0 ++
	ELSE
		SWAP CHARA_LIST:(LOCAL:0 - 1), CHARA_LIST:(LOCAL:0)
		LOCAL:0 --
	ENDIF
WEND


;各クラスを列表化表示
;とても无造作にCLASS内に存在するものを提示する、そんだけ
@CLASS_LIST(CLASS_NAME, CHECK_NAME)
#DIMS CLASS_NAME  ;表示对象となるクラスの名称
#DIMS CHECK_NAME  ;判定对象项目（INT限定）、未设定なら存在するものを全部表示
IF STRLENS(CHECK_NAME)
	FOR LOCAL, OBJ_ID_FIRST, OBJ_ID_LAST + 1
		SIF !GET_INT(0, CLASS_NAME, LOCAL, CHECK_NAME)
			CONTINUE
		PRINTFORML [{LOCAL, 3}] - %GET_STR(0, CLASS_NAME, LOCAL, "名前")%
	NEXT
ELSE
	FOR LOCAL, OBJ_ID_FIRST, OBJ_ID_LAST + 1
		SIF !STRLENS(GET_STR(0, CLASS_NAME, LOCAL, "名前"))
			CONTINUE
		PRINTFORML [{LOCAL, 3}] - %GET_STR(0, CLASS_NAME, LOCAL, "名前")%
	NEXT
ENDIF

