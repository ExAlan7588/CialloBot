;キーワードヘルプファイル
;-------------------------------------------------------------------------------------------------------
;erabasic文法
;-------------------------------------------------------------------------------------------------------
;=======================================================================================================
;excom(基本的にEmuera Wikiの丸パクリ)
;=======================================================================================================

;PRINT系
PRINT,PRINTV,PRINTS,PRINTL,PRINTW,PRINTFORM,PRINTFORMV,PRINTFORMS,PRINTFORML,PRINTFORMW /// PRINT(|V|S|FORM|FORMS)(|K|D)(|L|W)\nPRINT系の基本となる命令です。\n1つ目の括弧内のキーワードは引数タイプを指定します。\n\n    なし - (<文字列>)\n    V - (<数式> <数式> ,<数式> ……)\n    S - <文字列式>\n    FORM - (<书式付文字列>)\n    FORMS - <书式付文字列式> \n\n2つ目の括弧内のキーワードの"K"はFORCEKANA命令の適用を指定します。またキーワード"D"はSETCOLOR命令を无视することを指定します。ver1.736現在、キーワードKとDを同时に指定することはできません。\n\n    なし - FORCEKANAを无视し、SETCOLORで指定された色で描画します。\n    K - FORCEKANAを適用して描画します。\n    D - SETCOLORを无视してコンフィグで指定されたディフォルト色で描画します。 \n\n3つ目の括弧内のキーワードは描画后の改行、WAITの有无を指定します。\n\n    なし - PRINTのみで改行やWAITは行いません。\n    L - PRINT后、改行します。\n    W - PRINT后、改行しWAIT命令を行います。 \n\nこれらの組み合わせにより、例えばPRINTSDWであれば、引数として<文字列式>を指定し、ディフォルト色で描画し、PRINT后にWAIT命令を行うことを意味します。 
PRINTSINGLE /// PRINTSINGLE(|V|S|FORM|FORMS)(|K|D)\nPRINTSINGLE系はPRINTLとほぼ同じですが、PRINTSINGLE系は文字列を折り返さず、必ず1行で表示します。\n画面端を超えた文字は描画されません。\nまた、自动的に改行が付与されるため、(|L|W)キーワードはありません。\n他のキーワードの意味はPRINT系と同じです。 
PRINTC /// PRINT(|FORM)(C|LC)(|K|D)\nPRINTC系命令です。\nコンフィグ"PRINTCの文字数"（初期值25）で指定した文字数になるように半角スペースを补ってPRINTする命令です。\nなお、EmueraではPRINTされた文字列のボタン化处理の中でPRINTC系命令を多少特别扱いしています。\n1つ目の括弧内のキーワードは引数タイプを指定します。\n\n    なし - <文字列>\n    FORM - <书式付文字列> \n\n2つ目の括弧内のキーワードは揃える位置を指定します。\n\n    C - 右に揃えます（左側に半角スペースを追加します）\n    LC - 左に揃えます。 \n\n3つ目の括弧内のK,DはPRINT系と同じです。 
PRINTDATA /// PRINTDATA(|K|D)(|L|W)\nPRINTDATA系命令です。 私家改造版readmeによれば、\n\n　书式：PRINTDATA (数值変数：省略可)\n　　　　　DATA (文字)\n　　　　　DATAFORM (FORM文字列)\n　　　　　DATALIST\n　　　　　　(DATA or DATAFORMの羅列)\n　　　　　ENDLIST\n　　　　ENDDATA\n　内容：DATA、DATAFORMおよびDATALIST～ENDLISTで指定した文字列を確率均一でランダムで表示\n　　　　IFとRANDを使わずにランダム表示を实装可能\n　　　　引数に数值変数を指定した场合は表示された変数DATAの番号が入ります\n　　　　表示された文字列によって后の处理をいじりたい场合にどうぞ\n　　　　DATALIST～ENDLIST内ではDATAorDATAFORM1個が1行に相当します\n\nとのことです。\nK、D、L、Wキーワードの效果はPRINT系と同じです。\nPRINTDATA系～ENDDATAの内部にDATA系による表示データが与えられてない场合、何もせずに次に進みます。\nPRINTDATA系～ENDDATA、およびDATALIST～ENDLIST内に上记の文法以外の记述をすることはできません。
PRINTBUTTON /// PRINTBUTTON(|C|LC) <文字列式>, <数式 or 文字列式>\nPRINTBUTTON命令はマウスでクリックできるボタンを生成するための命令です。\n书式としてはPRINTS命令に近いですが、第二引数としてクリックされたときに入力する数字または文字を指定します。 第一引数に改行コードが入っている场合オミットされ改行されません。\n\nEmueraは"[300] セーブ"のように[]でくくられた数字とその前后の文字列を自动的にボタンに変换します。\nこのようなボタンを自动ではなく强制的に生成するための命令がPRINTBUTTONです。\nこの命令は例えば以下のような场合に有用です。\n\nPRINT これでいい？ [0] はい    [1] いいえ\nINPUT\n\nこのような行についてはEmueraはボタンを正しく認识できず、"これでいい？ [0] はい"というボタンと"[1] いいえ"というボタンになってしまいます。\nPRINTBUTTONを用いて书き直すと以下のようになります。\n\nPRINTS "これでいい？ "\nPRINTBUTTON "[0] はい", 0\nPRINTS "     "\nPRINTBUTTON "[1] いいえ", 1\nINPUT\n\n（PRINT命令の代わりにPRINTSを使っていますがこれは半角スペースの数を明らかにするためです）\nこのようにすると"これでいい？ "はボタンではなくなり、"[0] はい"と"[1] いいえ"だけがボタンになります。\nなお、PRITNBUTTON命令では表示する文字列に[0]や[1]などが含まれていることは必須ではありませんが、対応する数字を全く表示しないとテンキーなどで操作している方を戸惑わせることになるでしょう。 从来通り[0]などを表记することを勧めます。\n\nまた、PRINTBUTTON命令では数字だけでなく文字列を入力するボタンを作成することができます。 そうして作成したボタンはINPUTS命令の実行时にクリックすることができます。\n\nPRINTL 名前を入力してください。\nPRINTBUTTON "[ほげほげ] ", "ほげほげ"\nPRINTBUTTON "[ぷげぷげ] ", "ぷげぷげ"\nPRINTBUTTON "[ふうばあ] ", "ふうばあ"\nINPUTS\n\n括弧内のキーワードは文字を揃える位置を指定します。\n\n    なし - 揃えません\n    C - PRINTCと同様に右側に揃えます\n    LC - PRINTLCと左に揃えます 
PRINTPLAIN /// PRINTPLAIN(|FORM)\n引数の文字列を平文として出力します。この时ボタン文字列（0など）があってもボタン化しません。\n括弧内のキーワードは引数タイプを指定します。\n\n    なし - <文字列>\n    FORM - <书式付文字列> 
CUSTOMDRAWLINE,DRAWLINEFORM /// CUSTOMDRAWLINE <文字列>\nDRAWLINEFORM <FORM文字列>\n指定した文字列を使って1行の区切りを表示します。 DRAWLINEFORMではFORM構文に対応しています。 
REUSELASTLINE /// REUSELASTLINE <书式付文字列>\n最終行を指定した书式付き文字列で书き换えるが、\nこれを使って书き换えた行は、次の行が追加されるとそれに置き换わる\n基本的にはINPUT、INPUTSのループ处理の中でのみ使用するもの\n引数はPRINTFORMと同様の书式を使用可\nなお、REUSELASTLINE （この半角スペース必須）とすれば、警告文なしで空行にできます\n\n　　$INPUT_LOOP\n　　INPUT\n　　IF RESULT != 0\n　　　　;!;CLEARLINE 1 \n　　　　;!;REUSELASTLINE 无效ですよ\n　　　　GOTO INPUT_LOOP\n　　ENDIF\n\nのように、GOTO INPUT_LOOPの前にREUSELASTLINEを呼び出すと、\n前の入力が画面から消去され、次の入力は前の入力と同じ行に表示される\nこれによって、无效な入力が繰り返されても、行数が増えず、\n气づいたら选择肢が画面外に…なんて事态は防げる…はず\n\nちなみに@USERXXX系関数の条件分岐の最后に\n（対象は@USERCOM、@USERSHOP、@USERABLUPの3つ）\n\n　　;!;ELSE\n　　　　;!;REUSELASTLINE \n　　ENDIF\n\nとやっておくと…？\n(Emuera専用なら;!;は必要なし) 
CLEARLINE /// CLEARLINE <消す行数>\n指定した行数の文字列を削除します（行の数え方はLINECOUNTと同様です）\n行数はPRINTL等で改行が行われるまでのものを1つの行とします。\nなお、长い文字列が複数行に分割されたものもまとめて1行として扱うので气をつけてください。 
PRINT_IMG /// PRINT_IMG <文字列式>\n行中に指定した画像を表示します。\nHTML_PRINT命令の<img>タグに相当します。 
PRINT_RECT /// PRINT_RECT <数式>\n行中に横幅がフォントサイズの引数％である长方形を表示します。\nSETCOLOR命令によりフォント色と同様に色を変えられます。\nHTML_PRINT命令の<shape type='rect'>タグに相当します。 \n\nPRINT_RECT <数式>, <数式>, <数式>, <数式>\n行中にx,y,横幅,縦幅がそれぞれ引数％である长方形を表示します。\nSETCOLOR命令によりフォント色と同様に色を変えられます。\nHTML_PRINT命令の<shape type='rect'>タグに相当します。 
PRINT_SPACE /// PRINT_SPACE <数式>\nフォントサイズの引数％分だけ何も表示しないスペースを作ります。\nHTML_PRINT命令の<shape type='space'>タグに相当します。 


;表示操作・フォント操作・表示仕様参照
SETCOLOR,RESETCOLOR /// SETCOLOR <R>, <G>, <B>\nSETCOLOR <RGB>\nRESETCOLOR\n文字色を指定した色に変更、適用はRESETCOLORが呼ばれるまで。\n指定方法はRGB形式になります\nSETCOLORで指定した色はRESETCOLORでリセットすることができます\n現在の背景色はGETCOLORで、デフォルトの背景色はGETDEFCOLORで取得することができます。\n1.731以降ではSETCOLORに0xRRGGBB形式で指定できるようになりました。\n\nSETCOLOR 255, 128, 0\nSETCOLOR 0xFF8000\n\nこれはどちらの行も同じ意味になります。 GETCOLOR命令で取得できる值は后者です。 
SETBGCOLOR,RESETBGCOLOR /// SETBGCOLOR <R>, <G>, <B>\nSETBGCOLOR <RGB>\nRESETBGCOLOR\n背景色を指定した色に変更する命令です。\n基本的な仕様はSETCOLOR・RESETCOLORと同様ですが、\n安全のため変更后0.2秒以内に再変更する场合は0.2秒経過まで强制WAITになります。\n現在の背景色はGETBGCOLORで、デフォルトの背景色はGETDEFBGCOLORで取得することができます。 
SETCOLORBYNAME,SETBGCOLORBYNAME /// SETCOLORBYNAME <文字列>\nSETBGCOLORBYNAME <文字列>\n定義済み色名からフォント表示色や背景色を指定する命令です。\n他の仕様はすべてSETCOLOR・SETBGCOLORと同様です。 引数は色名です。定義済み色名についてはKnownColor列挙体 に準拠しておりますので、そちらを参照してください。 
GETCOLOR /// GETCOLOR\n現在使用している文字色コードをRESULT:0に代入します。\n戻り值は16進数で0xRRGGBBとなります。\n例えばオレンジ色(R,G,B) = (255, 128, 0)であれば0xFF8000(10進数で16744448)を返します。\n色と数字の対応はweb colorについて解説しているWebサイトを参考にするとよいでしょう。\n1.731での変更により、SETCOLOR命令もSETCOLOR 0xFF8000のような形式で指定できるようになりました。 
GETDEFCOLOR /// GETDEFCOLOR\n\nコンフィグで指定している文字色コードをRESULT:0に代入します。\n基本的な仕様はGETCOLORと同様です。 
GETBGCOLOR /// GETBGCOLOR\n\n現在使用している背景色コードをRESULT:0に代入します。\n基本的な仕様はGETCOLORと同様です。 
GETDEFBGCOLOR /// GETDEFBGCOLOR\n\nコンフィグで指定している背景色コードをRESULT:0に代入します。\n基本的な仕様はGETCOLORと同様です。 
FONTBOLD,FONTITALIC,FONTREGULAR /// FONTBOLD\nFONTITALIC\nFONTREGULAR\n\n以降の文字を指定したスタイルに変更する\nBOLDとITALICは重複可（太字斜体）\nREGULARを呼ぶと、太字・斜体指定が解除されます 
FONTSTYLE /// FONTSTYLE <数式>\n\n　FONTSTYLE以降の文字を指定したスタイルに変更します。\n　0であれば通常、1なら太字、2なら斜体、4なら打ち消し线、8なら下线が引かれます。\n　これらはビットごとに組み合わせることができます。\n　例えばFONTSTYLE 3なら太字かつ斜体になります。\n　FONTBOLD、FONTITALICは現在のスタイルに太字、斜体スタイルを加えます。\n　FONTREGULARはFONTSTYLE 0と等価です。つまり通常のスタイルに戻します。\n\n　　FONTSTYLE 1 + 2\n　　PRINTL 太字＋斜体\n　　FONTSTYLE 5\n　　PRINTL 太字＋打ち消し\n　　FONTITALIC\n　　PRINTL 太字＋斜体＋打ち消し\n　　FONTSTYLE 0\n　　PRINTL 通常\n<表示結果は実際に試してみてください>\n
GETSTYLE /// GETSTYLE\n\n現在のフォントのスタイル（太字、斜线など）をRESULT:0に代入します。\nこれはSETSTYLE命令で指定した值と同じです。\nSETSTYLE命令が行われていない时は0を返します。 
CHKFONT /// CHKFONT <文字列式>\n\n指定された名前のフォントがインストールされているかどうかを調べます。\nインストールされていれば1、されていなければ0がRESULT:0に代入されます。\n使用例はSETFONT命令を参照してください。 
SETFONT /// SETFONT <文字列式>\n\nSETFONT命令以降の文字列表示に指定された名前のフォントを用います。\n引数を省略、または空文字列を指定した场合、emuera.configに指定された標準のフォントに戻します。\n指定されたフォントがインストールされていない场合、代わりに"Microsoft Sans Serif"が使用されます。\nインストールされていない可能性があるフォントを指定する场合はSETFONTの前にCHKFONT命令を行ってください。\n\n　　PRINTL abc123あいう(標準フォント)\n　　CHKFONT "ＭＳ Ｐゴシック"\n　　IF RESULT\n　　　　SETFONT "ＭＳ Ｐゴシック"\n　　　　PRINTL abc123あいう(ＭＳ Ｐゴシック)\n　　ENDIF\n　　CHKFONT "ＭＳ 明朝"\n　　IF RESULT\n　　　　SETFONT "ＭＳ 明朝"\n　　　　PRINTL abc123あいう(ＭＳ 明朝)\n　　ENDIF\n　　STR:0 = ＭＳ Ｐ明朝\n　　CHKFONT STR:0\n　　IF RESULT\n　　　　SETFONT STR:0\n　　　　PRINTL abc123あいう(ＭＳ Ｐ明朝)\n　　ENDIF\n　　SETFONT
GETFONT /// GETFONT\n\n現在使用しているフォントの名前をRESULTS:0に代入します。\nこれはSETFONT命令で指定した名前と同じです。\nSETFONT命令が行われていない时はemuera.configで指定されている標準のフォントの名前を代入します。 
FORCEKANA /// FORCEKANA <数式>\n\n表示命令のひらがな・カタカナを指定します。\nキーワード"K"を含む各种PRINT系命令で有效になります。\n引数で指定した值により、以下の影響があります。\n\n    0:変换を行わない\n    1:ひらがな→カタカナ\n    2:カタカナ→ひらがな（全角のみ）\n    3:カタカナ→ひらがな（全角・半角两方とも） 
ALIGNMENT /// ALIGNMENT <キーワード>\n\nALIGNMENT以降の行を指定した位置に揃えます。\nキーワードには"LEFT"、"CENTER"、"RIGHT"のいずれかを指定します。\n通常の表示はALIGNMENT LEFTであり、左端に揃えられます。\nALIGNMENT CENTERによりタイトル画面のように中央に揃えることができます。\nALIGNMENTが適用されるのは改行された时点です。\n\n　　ALIGNMENT RIGHT\n　　PRINT あああ\n　　ALIGNMENT CENTER\n　　PRINTL いいい\n　　ALIGNMENT LEFT\n\nこのようにすると、"あああいいい"という文字列が中央揃えで表示されます。\n現在のALIGNMENTはCURRENTALIGNで取得することができます。
CURRENTALIGN /// CURRENTALIGN\n\n現在のALIGNMENTをRESULTS:0に代入します。\n返值はALIGNMENT命令で指定した文字列と同じです（大文字）。\nALIGNMENT命令が行われていない时は初期值のLEFTを返します。
REDRAW /// REDRAW <数式>\n\n描画制御命令です。\n引数に0を指定するとユーザーが入力を必要とするタイミングでのみ描画を行うようにします。\n引数に1を指定すると通常通り、コンフィグの"フレーム毎秒"で指定されたタイミングで描画を行います。\n引数に2を加えると(REDRAW 2やREDRAW 3など)、上记の效果に加え、REDRAW命令を行った瞬间に强制的に描画を行います。\n現在のREDRAW状态（0または1）はCURRENTREDRAWで取得することができます。
CURRENTREDRAW /// CURRENTREDRAW\n\n現在のREDRAW状态をRESULT:0に代入します。\n返值は通常时は1、REDRAW命令を用いて描画を抑制した时は0になります。
PRINTCPERLINE /// PRINTCPERLINE\n\nコンフィグ"PRINTCを并べる数"で指定された数をRESULT:0に代入します。標準は3です。
LINEISEMPTY /// LINEISEMPTY\n\n現在PRINTしている行が空行かどうかを判断する命令です。\nこの命令を実行した时点で「PRINTL 」を行おうとした场合、\nその結果がただの空行になる场合には1を、そうでない场合は0をRESULT:0に代入します。\nPRINTC系で条件に応じたボタンを顺次书き连ねる场合に、最后にこの命令を使用することで、\n表示されるボタンがあるかないかを判别し、なければ専用の表示をするといったことが可能です
BARSTR /// BARSTR <変数>, <最大值>, <长さ>\n\n与えられた引数と同一の引数のBAR命令で表示される文字列と同じ物をRESULTS:0に代入します。
MONEYSTR /// MONEYSTR <数值>{, <书式指定子>}\n\n引数で与えられた数值に対して、设定されたお金の単位を付けた文字列をRESULTS:0に代入します。\n単位の前置・后置も自动的に处理します。\n第2引数はTOSTR命令と同様の数值の文字列化における変换书式指定子となります。
SKIPDISP /// SKIPDISP <数值>\n\n以下、私家改造版更新履历より、\n\nPRINT等の画面出力命令およびWAIT、TWAITなどの命令を无视するフラグを设定する命令SKIPDISP追加\n　书式：SKIPDISP <数值>\n　引数：0 　　无视しないようにする\n　　　　0以外 无视するようにする\n　内容：このフラグを立てると、PRINT等の出力が一切行われなくなる\n　　　　また、このフラグが立ってる间にINPUTおよびINPUTSに達した场合は\n　　　　ユーザーが何をすればいい知る術がないこと、また飛ばせば无限ループに入る可能性が高いため\n　　　　警告文と対処法を明示した上でエラーになるようにしてあります\n　　今一般に使われる口上の实装では口上の非表示が可能な场合、\n　　表示と非表示でコマンドの結果が変わったり、动作が変わってしまう场合がある\n　　そこで、これを立てた上で口上を呼び出せば、表示はされることなくそれ以外の处理が行われるため\n　　表示/非表示で同じ动作を期待できる\n　　INPUT/INPUTSがかぶる场合は上のNOSKIP～ENDNOSKIPで囲んだり、\n　　SKIPDISP 0しておいて、INPUT处理后に再度SKIPDISP 1するなりの対策があります（一応前者推奨）\n　　ちなみに今无视するフラグが立ってるかはISSKIP()式中関数で取得できます\n\nver1.808から、SIF文の直后に置いても动作するようになりました。 なお、SKIPDISPを使用すると引数に关系なくRESULT:0が0にリセットされますが仕様となります。
NOSKIP,ENDNOSKIP /// NOSKIP\nENDNOSKIP\n\n以下、私家改造版更新履历より、\n\n表示关系无视フラグを无视する区间を指定できるNOSKIP～ENDNOSKIP实装\n　　この2つで囲った区间はSKIPDISP 1の状态でも表示等される\n　　主にINPUTが必要な场合に使用するとよい\n　　また、この命令はSKIPDISPの状态に影響しないので、\n　　SKIPDISPフラグが立ちうる环境下のコード（例えば表示/非表示のある口上关系）では\n　　これを使うと、絶対に表示する必要がある场所をきちんと表示できるようになります
ISSKIP /// ISSKIP\n\nSKIPDISPのフラグが0以外（PRINT等の出力を无视）なら1を、そうでなければ0をRESULT:0に代入します
MOUSESKIP /// MOUSESKIP\n\n右クリックが押されてWAITスキップの状态になっているなら1を、そうでなければ0をRESULT:0に代入します\nマクロ处理时のスキップ中は0を返します\nマクロ处理のスキップと右クリックが競合した场合はマクロを优先し0を返します 


;文字列操作・参照
TOUPPER,TOLOWER,TOHALF,TOFULL /// TOUPPER <文字列式>\nTOLOWER <文字列式>\nTOHALF <文字列式>\nTOFULL <文字列式>\n\n引数の文字列に特定の変换をかけた結果をRESULTS:0に代入します。\nTOUPPERはアルファベットを大文字にした結果を、TOLOWERは小文字化した結果を代入します\nTOHALFは全角文字を半角にしますが、対応する半角文字がない全角文字はそのままです。\nTOFULLは半角文字を全角にします。 
TOSTR /// TOSTR <数式>, <书式指定子>\n\n数值を文字列に変换する命令です。\n変换したい数字を第一引数に、変换の书式を文字列で第二引数に指定します。\n第二引数は省略できますが、省略した场合はPRINTFORMの{}内などと同じように単に文字列になります。\nこの関数は内部でC#のInt64.ToString()関数を呼んでおり、C#と同じ书式指定ができます。第二引数が適切でない场合、エラーになります。\n简単な书式指定の例は同名の式中で使える関数を确认してください。 书式指定の详细はC#の数值书式指定文字列について解説しているWebサイトを参考にして下さい。 
TOINT /// TOINT <文字列式>\n\n引数文字列を数值化してRESULT:0に代入します。ただし、半角数字で構成された文字列のみ数值化できます。\n引数を数值として解釈できない场合、0が代入されます。全角数字の场合も同様です。 
STRLEN,STRLENS,STRLENFORM /// STRLEN <文字列>\nSTRLENS <文字列式>\nSTRLENFORM <书式付文字列>\n\n文字列の长さを测定し、RESULT:0に代入します。\n长さはSHIFT-JISでのバイト数です。つまり全角文字を2文字と数えます。\n\n　　STRLEN ABCあいう\n　　PRINTFORML <TEST1> = {RESULT}\n　　STR:0 = ABCあいう\n　　STRLENS STR:0\n　　PRINTFORML <TEST2> = {RESULT}\n　　STRLENFORM abc%STR:0%\n　　PRINTFORML <TEST3> = {RESULT}\n\n　　;STRLENSは文字列式にも対応\n　　STRLENS "abc" + STR:0\n　　PRINTFORML <TEST4> = {RESULT}\n　　WAIT\n　結果\n　<TEST1> = 9\n　<TEST2> = 9\n　<TEST3> = 12\n　<TEST4> = 12\n
STRLENU,STRLENSU,STRLENFORMU /// STRLENU <文字列>\nSTRLENSU <文字列式>\nSTRLENFORMU <书式付文字列>\n\nSTRLEN、STRLENS、STRLENFORMのUnicode版です。違いは全角文字も1文字と数えることです。 
SUBSTRING,SUBSTRINGU /// SUBSTRING <文字列式>, <数式>, <数式>\n\n指定した文字列式の部分文字列をRESULTS:0に代入します。\n开始位置は文字列の最初が0です。元文字列の长さより后を指定した场合、空文字列""が返されます。\n文字数はSHIFT-JISでのバイト数で指定します。つまり全角文字を2文字と数えます。\n文字数に負の值を指定するか、元文字列の終端より后の位置を指定した场合、开始位置から最后までの文字列を返します。\n开始位置または終了位置で文字を切ることができない场合（全角文字の途中を指している场合）、1つ后ろを指定されたと判断されます。\nこのことで指定した文字数よりも1文字分だけ长い文字列が返される场合があるので注意してください。\n\n　　STR:0 = 01234あいうえお\n　　SUBSTRING STR:0, 0, -1\n　　PRINTFORML <TEST1> = %RESULTS:0%\n　　SUBSTRING STR:0, 1, 3\n　　PRINTFORML <TEST2> = %RESULTS:0%\n　　SUBSTRING STR:0, 6, 3\n　　PRINTFORML <TEST3> = %RESULTS:0%\n　　WAIT\n　結果\n　<TEST1> = 01234あいうえお\n　<TEST2> = 123\n　<TEST3> = いう\n\nSUBSTRINGU <文字列式>, <数式>, <数式>\n\nSUBSTRINGのUnicode版です。違いは全角文字も1文字と数えることです。 
STRFIND,STRFINDU /// STRFIND <文字列式>, <文字列式>(, <数式>)\n\n文字列検索命令です。\n第一引数には検索される対象の文字列を文字列式で、\n第二引数には検索する文字列を文字列式で指定します。\nRESULT:0に全角文字を2文字と数え、0から始まるインデックスが代入されます。見つからなかった场合は-1です。\n\n　　STR:0 = abcdefghi\n　　STR:1 = あいうえお\n　　STR:2 = うえ\n　　STRFIND STR:0, "cde"\n　　PRINTFORML <TEST1> = {RESULT:0}\n　　STRFIND STR:1, "いうえ"\n　　PRINTFORML <TEST2> = {RESULT:0}\n　　STRFIND STR:1, STR:2\n　　PRINTFORML <TEST3> = {RESULT:0}\n　　STRFIND STR:1, "か"\n　　PRINTFORML <TEST4> = {RESULT:0}\n;結果\n<TEST1> = 2\n<TEST2> = 2\n<TEST3> = 4\n<TEST4> = -1\n\n1.712以降、STRFIND命令に第3引数が指定できるようにしました。\n第3引数には検索の开始位置を0から始まるインデックスで指定します。\n\n　　STRFIND "abcdeabced","a",3\n\n上の行の結果、RESULTには5が代入されます。\n"a"は0の位置にもありますが、第3引数により検索は3の位置("d")から开始されるので最初に見つかる"a"は5の位置になります。\n\n\nSTRFINDU <検索対象>, <検索する文字列>{, <开始インデックス>}\n\n以下、私家改造版更新履历より、\n\nSTRFINDのユニコード版STRFINDU实装\n　书式：STRFINDU(<検索対象>, <検索する文字列>{, <开始インデックス>})\n　内容：STRFINDのユニコード版、返り值の文字の位置と开始インデックスがユニコードでのカウントになっている\n
STRCOUNT /// STRCOUNT <検索対象文字列>, <検索文字列>\n\n文字列中の指定部分文字列の数を取得する命令です。ヒットした数をRESULT:0に代入します。\n検索文字列の书式はC#の正规表現の仕様に準じます。 
SPLIT /// SPLIT <文字列式>, <文字列式>, <文字列変数>\n\n第1引数で指定した文字列を、第2引数で指定した文字列を区切りとして分割し、第3引数で指定した文字列配列変数に代入します。\nまた、分割した数をRESULTに代入します。\n第3引数で指定する変数は配列変数でなければなりません。\n\nSPLIT "あい,うえ,,お", ",", LOCALS\n\n上记のスクリプトの結果、LOCALS:0に"あい"、LOCALS:1に"うえ"、LOCALS:2に""（空文字列）、LOCALS:3に"お"、RESULTに4が代入されます。\n分割后の要素数が第3引数に代入可能な要素数を超えた分については代入が行われません\nRESULTには実際の分割数が入れられるのでそちらで判别してください
REPLACE /// REPLACE <置换対象文字列>, <置换対象パターン>, <置换后の文字列>\n\n以下、私家改造版更新履历より、\n\n文字列置换命令REPLACE实装\n　书式：REPLACE(<置换対象文字列>, <置换対象パターン>, <置换后の文字列>)\n　内容：置换対象文字列を置换対象パターンで検索し、ヒットしたら置换后の文字列で置き换えます。結果はRESULTSに代入されます。\n　　内部处理は思いっきり正规表現です。第２引数はC#の正规表現の仕様に準じて动作します。\n　　そのため、()や[]、$、/.*+等の正规表現で用いられる记号はエスケープ必須となります
ESCAPE /// ESCAPE <文字列>\n\n以下、私家改造版更新履历より、\n\n文字列を正规表現用にエスケープする式中関数ESCAPEを追加\n　书式：ESCAPE([文字列])\n　内容：文字列が正规表現中で平文となるように、引数中の文字列の正规表現メタ文字をエスケープして返す
UNICODE /// UNICODE <数式>\n\nRESULTS:0に引数の值に対応したunicodeの文字を代入する命令です。\n例えば、以下のスクリプトは白抜きのハートマークを表示します。\nただし、この関数ではサロゲートペアを扱うことはできません。\nまた、フォントが対応していなければ表示できません。\n\nUNICODE 0x2661\nPRINTFORMW %RESULTS%\n\nなお、EmueraのUnicode対応は完全ではないことに注意してください。\n例えばEmueraはサロゲートペアを使用した场合、正確な动作は保証できません。
ENCODETOUNI /// ENCODETOUNI <対象文字列(FORM型文字列)>\n\n以下、私家改造版更新履历より、\n\n文字列に対してUNICODEのバイトコードを返すENCODETOUNI实装\n　书式：ENCODETOUNI <対象文字列(FORM型文字列)>\n　内容：与えられた文字列をユニコードにエンコードしてそのバイトを数值として返す\n　　　　RESULT:0 　文字数\n　　　　RESULT:1～ バイト数值


;算術
POWER /// POWER <変数>, <数式>, <数式>\n\n　指定した変数に累乗を代入します。\n　例えばPOWER A, X, Y ならば、AにXのY乗が代入されます。\n　演算結果がオーバーフローを起こすとエラーになります。\n\n　　X = 11\n　　Y = 2\n　　POWER A, X, 2\n　　PRINTFORML <TEST1> = {A}\n　　POWER CFLAG:2, X + 1, Y + 1\n　　PRINTFORML <TEST2> = {CFLAG:2}\n　結果(TARGETは適切に设定されているとする)\n　<TEST1> = 121\n　<TEST2> = 1728
ABS /// ABS <数式>\n\n引数の絶対值をRESULT:0に代入します。
SIGN /// SIGN <数式>\n\n引数の符号をRESULT:0に代入します。\n負の值なら-1、0なら0、正の值なら1を代入します。
SQRT /// SQRT <数式>\n\n引数の平方根をRESULT:0に代入します。
GETBIT /// GETBIT <数式>, <数式>\n\n引数の特定のビットを取得し、RESULT:0に代入します。\n第1引数に対象となる数字を、第2引数には取得したいビットの位置を指定します。 第2引数に指定できる值は0～63までで、範囲外の数值を指定するとエラーになります。\n第2引数が定数の场合、例えば5であれば、\n\n　　GETBIT X, 5\n　　RESULT = (X & 1p5) != 0\n\n2つの行は同じ結果になります。
MAX /// MAX <数式>(, <数式>...)\n\n引数の中で最大の数值をRESULT:0に代入します。
MIN /// MIN <数式>(, <数式>...)\n\n引数の中で最小の数值をRESULT:0に代入します。
LIMIT /// LIMIT <数式>, <数式>, <数式>\n\n第一引数の值をRESULT:0に代入します。\nただし、第一引数が第二引数より小さいなら第二引数の值を、第三引数より大きいなら第三引数を返します。\n例えばAに X - Y を代入したいが、代入后の值が0以上100以下であってほしい场合、通常は以下のように书きます。\n\nA = X - Y\nSIF A < 0\n　　A = 0\nSIF A > 100\n　　A = 100\n\nLIMIT命令を使うとこれを二行にまとめることができます。\n\nLIMIT X - Y, 0, 100\nA = RESULT
INRANGE /// INRANGE <数式>, <数式>, <数式>\n\n第一引数の值が第二引数以上かつ第三引数以下であれば1を、第一引数が第二引数より小さい、または第三引数より大きいなら0をRESULT:0に代入します。
SETBIT,CLEARBIT,INVERTBIT /// SETBIT <数值型変数>, <数式>{, <数式>,...}\nCLEARBIT <数值型変数>, <数式>{, <数式>,...}\nINVERTBIT <数值型変数>, <数式>{, <数式>,...}\n\nビット操作関数です。\n第1引数で指定した変数の、第2引数以降で指定した位置のビットを操作します。\nSETBITはビットを1にし、CLEARBITは0にし、INVERTBITは反转させます。\n\n　　SETBIT X, A\n　　CLEARBIT Y, B\n　　INVERTBIT Z, C\n\nの結果は以下と同じです。\n\n　　X |= 1 << A\n　　Y &= ~(1 << B)\n　　Z ^= 1 << C\n\nまた、これらのビット操作関数の书式はGETBIT関数と対応しています。\n"SETBIT X, A" で変更したビットをGETBIT(X, A)で参照することができます。 


;キャラ操作・参照
ADDCHARA,DELCHARA /// ADDCHARA <数式>(, <数式>, <数式>, ...)\nDELCHARA <数式>(, <数式>, <数式>, ...)\n\neramakerからある命令ですが、一度にたくさんのキャラを足したり消せるようになりました
SWAPCHARA /// SWAPCHARA <数式>, <数式>\n\n指定した二人のキャラクタの登录番号を入れ替えます。\n\n　　;MASTERしかいない状态とする\n　　ADDCHARA 10\n　　ADDCHARA 11\n　　PRINTFORML NO:1 = {NO:1}, NO:2 = {NO:2}\n　　SWAPCHARA 1,2\n　　PRINTFORML NO:1 = {NO:1}, NO:2 = {NO:2}\n　結果\n　NO:1 = 10, NO:2 = 11\n　NO:1 = 11, NO:2 = 10
SORTCHARA /// SORTCHARA <キャラクタ変数> {, <FORWARDorBACK>}\n\n任意のキーによる、キャラリストのソート。\nソートキーはNAMEのような文字列変数、NOのような数值型変数、CFLAGのような数值配列変数のいずれでも可能です。\n<キャラクタ変数>は省略することができ、その场合はキャラ番号(NO:XX)でソートされます。\nFORWARDなら昇顺、BACKなら降顺になります。省略した场合は昇顺でソートされます。\nMASTERはソートの対象になりません。\nまた、TARGET:0、ASSI:0は自动で追尾されますので使用后に手动で操作する必要はありません。\nしかしTARGET:1などを使用しているバリアントはこれらを手动で追随させる必要があります。\n\n　　;NOで昇顺にソート\n　　SORTCHARA \n　　;NOで降顺にソート\n　　SORTCHARA BACK\n　　;CFLAG:2で昇顺にソート\n　　SORTCHARA CFLAG:2\n　　;NAMEで降顺にソート\n　　SORTCHARA NAME, BACK\n\nなお、TARGET == -1の场合でも、CFLAG:2などの值を実際に参照するわけではないのでエラーにはなりません。
GETCHARA /// GETCHARA <キャラ番号(NO:XXXの方)>\n\n現在所有しているキャラの中にそのキャラがいるかを判定し、いればリスト上での位置を、いなければ-1を返します\nリスト全体から特定のキャラの有无を确认したい场合に使えます
ADDDEFCHARA /// ADDDEFCHARA\n\nゲーム开始时のシステム的なキャラ追加处理を行う命令です。\nchara0*.csvで定義されたキャラと、gamebase.csvで指定された初期キャラを追加します。\n"ADDCHARA 0"はキャラNOが0であるキャラを探して追加しますが、ADDDEFCHARAはcsvの番号でキャラを追加します。\n該当するcsvが存在しない场合、ADDVOIDCHARA同様に空のキャラクタを作成します。\nこれはeramakerの初期化处理を再現するための命令であり、@SYSTEM_TITLE以外では使用できません。
ADDVOIDCHARA /// ADDVOIDCHARA\n\ncsvに依らずにキャラを追加する命令です。\nADDVOIDCHARAで追加されたキャラは全ての変数に0又は""(空文字列)が代入されています。
DELALLCHARA /// DELALLCHARA\n\n登录されている全てのキャラクタを削除します。 以下のスクリプトと同じことです。\n\nREPEAT CHARANUM\n　　DELCHARA 0\nREND
PICKUPCHARA /// PICKUPCHARA <対象キャラ>(, <対象キャラ>, ....)\n\n引数で指定したキャラのみを残し、他のキャラを全て削除する命令です。\nMASTER:0、TARGET:0、ASSI:0などは自动で追随します。命令后手动で设定し直す必要はありません。\n対象キャラに負の值を指定した场合エラーになりますが、MASTER、TARGET、ASSI等を対象に设定し、\nその結果それらの変数の中身が負の值だった场合は、例外でエラーになりません（无视される）。
EXISTCSV /// EXISTCSV <数式>\n\n対応するキャラが定義されているかどうかをチェックしRESULT:0に代入します。\n定義されていれば1、されていなければ0を返します。\nADDCHARA noがエラーにならずに実行できるかどうかを調べることができます。
FINDCHARA,FINDLASTCHARA /// FINDCHARA <キャラクタ変数>, <式>(, <数式>, <数式>)\nFINDLASTCHARA <キャラクタ変数>, <式>(, <数式>, <数式>)\n\nFINDCHARA命令はキャラクタ変数と值を指定し、変数がその值であるキャラクタの登录番号をRESULT:0に返します。\n複数見つかった场合、FINDCHARAは最初にヒットしたキャラを、\nFINDLASTCHARAは最后にヒットしたキャラを返します。見つからなかった场合は-1を返します。\nまた、第3引数を指定することで検索の开始位置を、第4引数を指定することで検索の終了位置を指定できます。\nただし、検索範囲がキャラクタ数の範囲を超える场合はエラーとなります。\n\n　　X = -1\n　　WHILE 1\n　　　　FINDCHARA CFLAG:10, 123, X + 1\n　　　　X = RESULT\n　　　　SIF X < 0\n　　　　　　BREAK\n　　　　PRINTFORML %NAME:X%\n　　WEND
COPYCHARA /// COPYCHARA <数式>, <数式>\n\n第一引数で指定された登录番号のキャラの全てのデータを第二引数で指定された登录番号のキャラにコピーします。
ADDCOPYCHARA /// ADDCOPYCHARA <数式>\n\n引数で指定された登录番号のキャラと同じデータであるキャラを新たに追加します。つまり、ADDCHARAの変种です。


;変数操作・変数参照・CSV参照
VARSIZE /// VARSIZE <変数名>\n\n指定した変数の配列のサイズをRESULT:0に代入します。\n多次元配列変数の场合、一番左の要素から顺にRESULT:0, RESULT:1, RESULT:2と代入されます。\n配列のサイズはVariableSize.csvで指定した值です。\n\n　　VARSIZE FLAG\n　　PRINTFORML <TEST1> = {RESULT:0}\n　　VARSIZE SAVESTR\n　　PRINTFORML <TEST2> = {RESULT:0}\n　　VARSIZE TALENT\n　　PRINTFORML <TEST3> = {RESULT:0}\n　　WAIT\n　結果(サイズを変更していない场合)\n　<TEST1> = 10000\n　<TEST2> = 100\n　<TEST3> = 1000\n\n※実際に変数を参照するわけではないので配列外参照が发生することはありません。 上の例ではTARGET == -1の场合でも-1人目のTALENTを参照しようとしてエラー、ということにはなりません。
RESETDATA /// RESETDATA\n\nGLOBALとGLOBALSを除く全ての変数を初期化します。\n具体的には全てのキャラを削除し、全てのローカル変数および全ての通常の変数に0又は空文字列を代入します。\nまた、PALAMLVやSTRなど初期值が设定されている変数については初期值を代入します。
RESETGLOBAL /// RESETGLOBAL\n\nグローバル変数を初期化します。\n具体的にはGLOBALに0を代入し、GLOBALSに空文字列を代入します。
RESET_STAIN /// RESET_STAIN <数式>\n\n第1引数で指定したキャラクタのSTAINを初期化する命令です。 初期值はBEGIN TRAINのときに代入される值と同様で、_replace.csvの「污れの初期值」で指定できます。
SWAP /// SWAP <変数1>, <変数2>\n\n変数1と変数2の中身を入れ替えます\n交换する2つの変数は同じ型（整数型と整数型、文字列型と文字列型）である必要があります
CSVNAME,CSVCALLNAME,CSVNICKNAME,CSVMASTERNAME /// CSVNAME <数式>\nCSVCALLNAME <数式>\nCSVNICKNAME <数式>\nCSVMASTERNAME <数式>\n\nCSVで定義されたNAME、CALLNAME、NICKNAME、MASTERNAMEを直接呼び出す関数です。\n所有してないキャラの名前とかが欲しいときとかにどうぞ\n第一引数がキャラ番号(NOの方)です。
CSVBASE,CSVCSTR,CSVABL,CSVTALENT,CSVMARK,CSVEXP,CSVRELATION,CSVJUEL,CSVEQUIP,CSVCFLAG /// CSVBASE <数式>, <数式>\nCSVCSTR <数式>, <数式>\nCSVABL <数式>, <数式>\nCSVTALENT <数式>, <数式>\nCSVMARK <数式>, <数式>\nCSVEXP <数式>, <数式>\nCSVRELATION <数式>, <数式>, <数式>\nCSVJUEL <数式>, <数式>\nCSVEQUIP <数式>, <数式>\nCSVCFLAG <数式>, <数式>,\n\nCSVで定義された值を直接呼び出す関数です。\n第一引数がキャラ番号、第二引数が各変数のインデックスです。\nCSVCSTRはRESULTSに文字列を代入し、その他はRESULTに数值を代入します。
GETNUM /// GETNUM <変数名>, <文字列式>\n\n各csvで定義されている名称からその数值を取得し、RESULT:0に代入します。\n例えば、abl.csvで"2,技巧"が定義されていれば、GETNUM ABL, "技巧"の結果、RESULT:0に2が代入されます。\n定義されていない场合は-1になります。\ncsvと変数の対応はEmueraの扩张文法#一般のページの「文字列による配列変数の要素の指定」に準じます。
GETPALAMLV,GETEXPLV /// GETPALAMLV <数式>, <判定するLVの上限>\nGETEXPLV <数式>, <判定するLVの上限>\n\n与えられた值の内容とPALAMLV・EXPLVを比較し、その引数がPALAMLV・EXPLVでどこまで以上かをRESULT:0に代入します。\n第2引数は調査する最大のLVを表します。PALAMLV・EXPLVの值を设定してから使用してください。
FINDELEMENT,FINDLASTELEMENT /// FINDELEMENT <一次元配列変数>, <検索対象(変数と同型)>, <検索初位置>, <検索終位置>, <厳密一致かのフラグ>\nFINDLASTELEMENT <一次元配列変数>, <検索対象(変数と同型)>, <検索初位置>, <検索終位置>, <厳密一致かのフラグ>\n\n配列中の特定範囲から特定の要素の位置を取得する関数です。\n第3・第4引数で指定された配列要素の検索範囲に第2引数で指定されたものと同じ要素があれば、その位置を返します。\n複数ある场合はFINDELEMENTは最初にヒットしたものを、\nFINDLASTELEMENTは最后にヒットしたものを返します。ヒットしない场合は-1を返します。\n検索対象が文字列の场合はREPLACEと同様に正规表現を使えます。\n第5引数は文字列の场合のみ有效で、0であれば文字列の一部が一致でもOKとし、\n0以外であれば文字列と完全に一致した场合のみOKとします。
VARSET /// VARSET <変数名>{, <数式 or 文字列式>, <配列範囲初值>, <配列範囲終值+1>}\n\n指定した変数の配列の指定範囲に第二引数の值を代入します。\n第二引数を省略した场合、0または空文字列が代入されます。\n第三引数以降を省略した场合、配列の全てに代入されます。\n例えば\n\nVARSET FLAG, 0\nVARSET STR, "あああ", 0, 10\nVARSET TA:0:0:0,5678\n\nこの例ではFLAGの要素全てが0になります。\nSTR:0からSTR:9には"あああ"が代入され、TAについても三次元配列の全ての要素に5678が代入されます。\n同じことはERB上でFOR-NEXTループなどを使って行うこともできますが、ループ回数が数十万回程度になると実行时间が无视できなくなります。\nVARSET命令はERB上での代入よりはるかに早く处理を終わらせることができます。\n\nキャラクタ変数をVARSET命令の対象にした场合、指定したキャラの要素のみに代入されます。\n\nVARSET CFLAG:MASTER:0, 0\nVARSET CSTR, ""\n\nこの例ではMASTERのCFLAG:0～999（変更していなければ）が0になりますが、他のキャラのCFLAGは影響を受けません。\nまた、対象を省略した场合は通常通りTARGETとみなされるのでTARGETのCSTRが全て""になります。他のキャラのCSTRは影響を受けません。\n1次元配列および配列型キャラクタ変数以外の、DITEMTYPEやTA等に使用した场合、第三引数以降は无视され配列の全てに代入されます。
CVARSET /// CVARSET <キャラクタ変数>{, <数式>, <式>, <キャラクタ範囲初值>, <キャラクタ範囲終值+1>}\n\n指定した登录キャラクタについてキャラクタ変数の特定要素へ代入する命令です。\n第一引数で指定した変数の第四引数以降で指定した登录キャラクタについて、第二引数で指定した要素へ第三引数で指定した值を代入します。\nNAME、ISASSIなどの一次元配列変数の场合、第二引数は处理に影響しません。そのため第三引数を省略しない场合、適当な值を指定してください。\n第三引数を省略した场合、0又は""(空文字列)が代入されます。\n第二引数も省略した场合、0番目の要素に代入されます。\n第四引数以降を省略した场合、全ての登录キャラクタに代入されます。\n\nCVARSET CFLAG, 10, 123\n\nこのスクリプトは以下と同じことです。\n\nREPEAT CHARANUM\n　　CFLAG:COUNT:10 = 123\nREND
ARRAYSHIFT /// ARRAYSHIFT <対象変数>, <ずらす数>, <ずらしてできた空白領域の初期值>{, <ずらす配列範囲の初值>, <ずらす配列要素の範囲の数>}\n\n以下、私家改造版更新履历より、\n\n配列をシフトする命令ARRAYSHIFT实装\n　书式：ARRAYSHIFT <対象変数>, <ずらす数>, <ずらしてできた空白領域の初期值>{, <ずらず配列範囲の初值>, <ずらす配列要素の範囲の数>}\n　内容：配列変数を指定した数だけずらす、正の值で添え字の大きい方へ、負の值で小さい方にずらす\n　　　　配列の範囲からはみでた值は扫き捨て、ずらして出来た空白領域は第2引数で指定した值で満たす\n　　　　省略可能な第4および第5引数を使うと一部の範囲のみをずらすことができる\n\n1次元配列および配列型キャラクタ変数のみに対応しています。DITEMTYPEやTA等に使用することはできません。
ARRAYREMOVE /// ARRAYREMOVE <対象変数>, <消す範囲初值>, <消す要素数>\n\n以下、私家改造版更新履历より、\n\n配列要素を部分削除する命令ARRAYREMOVE实装\n　书式：ARRAYREMOVE <対象変数>, <消す範囲初值>, <消す要素数>\n　内容：配列変数を指定した初期值から要素数分だけ削除し、后ろを值を詰める\n　　　　消す要素数を0以下にすると初期值から后ろ全て消去になります\n\n1次元配列および配列型キャラクタ変数のみに対応しています。DITEMTYPEやTA等に使用することはできません。
ARRAYSORT /// ARRAYSORT <対象変数>{, <ソート方式(FORWARD or BACK)>, <开始インデックス>, <対象要素数>}\n\n以下、私家改造版更新履历より、\n\n配列変数をソートするARRAYSORT实装\n　书式：ARRAYSORT [対象変数](, [ソート方式(FORWARD or BACK)], [开始インデックス], [対象要素数])\n　内容：开始インデックスから対象要素数個の配列データをソートする\n　　　　FORWARDで昇顺、BACKで降顺
ARRAYCOPY /// ARRAYCOPY <コピー元変数名>, <コピー先変数名>\n\n以下、私家改造版更新履历より、\n\n无頓着な配列コピー命令ARRAYCOPY实装\n　书式：ARRAYCOPY <コピー元変数名>, <コピー先変数名>\n　内容：コピー元変数の值をコピー先変数へコピーする\n　　　　型変数は型が同じで次元数が同じである必要がある\n　　　　また、キャラクター変数には非対応\n　　　　要素数が异なる场合はコピーできる分だけコピーする\n\n书式例：ARRAYCOPY "A", "B"
CUPCHECK /// CUPCHECK <登录キャラクター番号>\n\n以下、私家改造版更新履历より、\n\nCUP、CDOWNに対応するUPCHECKであるCUPCHECK追加\n　书式：CUPCHECK <キャラ>\n　内容：引数で指定したキャラに対するUPCHECKを走らせる、それだけ\n\n当然ですがUP,DOWNの影響はありません。また、UPCHECKでは結果を表示していましたが、CUPCHECKによる結果は表示されません。 


;セーブデータ操作
SAVEDATA /// SAVEDATA <数式>, <文字列式>\n\n<数式>で示される番号のファイルに現在の状态をセーブします。\nSAVEDATA命令は@SAVEINFOを呼び出さないのでPUTFORMでコメントを入れることができません。\n代わりに2つ目の引数の<文字列式>でコメントを指定します。\n(1.704からは文字列変数だけでなく文字列式が使用できます) 以下に例を示します。\n\n　　GETTIME\n　　STR:0 = %RESULTS:0% {DAY+1}日目\n　　SAVEDATA 14, STR:0\n　　SAVEDATA 15, RESULTS:0 + " " + @"{DAY+1}日目"\n　結果(ロード画面)\n　[13] ----\n　[14] 2009年03月28日 00:31:27 1日目\n　[15] 2009年03月28日 00:31:27 1日目\n　[16] ----\n\n上书きの确认などは行わないので必要ならERB側で用意してください。\n既にデータがあるかどうかはCHKDATA命令で調べることができます。\nSAVEDATAは(SAVEGAME命令と違って)スクリプトのどの场所でも呼び出すことができます。
LOADDATA /// LOADDATA <数式>\n\n<数式>で示される番号のファイルのデータをロードします。\nロードに失敗した场合、エラー終了します。\n必ずCHKDATA命令でロード可能かどうかを調べてから実行してください。\nLOADDATAは(LOADGAME命令と違って)スクリプトのどの场所でも呼び出すことができます。
DELDATA /// DELDATA <数式>\n\n<数式>で示される番号のファイルのデータを削除します。\nファイルが存在しなくてもエラーにはなりません。
CHKDATA /// CHKDATA <数式>\n\n<数式>で示される番号のファイルのデータの情报をRESULT:0とRESULTS:0に代入します。\nRESULT:0は以下の值をとります。0の场合のみそのファイルをロードすることができます。\n\n    0 - このファイルはロード可能です。\n    1 - 指定されたファイルは存在しません。\n    2 - ゲームのコードが違います。(gamebase.csvの"コード"の值が違うデータ)\n    3 - バージョンが違います。(gamebase.csvの"バージョン"の值が异なり、許容されるバージョンでもないデータ)\n    4 - 上记以外の問題があるファイルです。 \n\nRESULT:0が0のとき、RESULTS:0にはセーブデータのコメント（@SAVEINFOのPUTFORMで入力した文字列、またはSAVEDATAの第２引数）が代入されます。\nRESULT:0が0以外のとき、RESULTS:0には"セーブデータのバーションが异なります"などのエラーメッセージが代入されます。
SAVENOS /// SAVENOS <数值変数>\n\nコンフィグ"表示するセーブデータ数"で指定された数を取得し指定された数值変数に代入します。標準は20です。\n数值変数を省略することはできません。
SAVEGLOBAL /// SAVEGLOBAL\n\n変数GLOBALとGLOBALSをセーブします。保存先は"global.sav"です。\nERHファイル内でGLOBAL及びSAVEDATAフラグを持つ変数が定義されていればそれもセーブします。
LOADGLOBAL /// LOADGLOBAL\n\nGLOBALとGLOBALSをロードします。保存先は"global.sav"です。\n読み込みに失敗してもエラーにはなりません。\n読み込みに成功するとRESULTに1を、失敗すると0を代入します。\n通常のセーブデータと同様に、gamebase.csvで设定されたコード、バージョンが適切でないファイルはロードできません。\n変数GLOBALの详细は変数の节を参照してください。
OUTPUTLOG /// OUTPUTLOG\n\n以下、私家改造版更新履历より、\n\nログ出力命令OUTPUTLOG实装\n　　やり過ぎはディスクの寿命を缩めるのでほどほどに\n\nなお、ログの文字コードはUnicodeです。
SAVECHARA /// SAVECHARA str filename, str memo, int charano{, int charano2, ...}\n\n指定したキャラクタのデータをファイルに保存する命令です。\n第一引数はデータをセーブするファイル名(の一部)を指定します。実際のファイル名は"chara_*.dat"になります。\n第二引数はセーブデータのメモとなる文字列を保存します。后にCHKCHARADATA関数により読むことができます。\n第三引数以降にはセーブしたいキャラの登录番号を指定します。いくつでも可能ですが同一の登录番号を複数回指定することはできません。\ndatフォルダーが存在しない场合、フォルダの作成を試みます。作成に失敗した场合エラーになります。\nまた、第一引数が空文字列である、第一引数にファイル名に使えない文字が含まれるなどの场合エラーになります。
LOADCHARA /// LOADCHARA str filename\n\n第一引数はデータをロードするファイル名(の一部)を指定します。実際のファイル名は"chara_*.dat"になります。\nRESULT:0に、読み取りに失敗した场合は0を、成功した场合は1を代入します。\nLOADVARの前にCHKCHARADATA関数によりファイルの適切さを确认すべきです。\nLOADCHARAはSAVEされているキャラの数だけ新しいキャラを登录します。\nしたがって既存の登录キャラには影響しません。\n何名のキャラが追加されたかを知るにはロード前后でのCHARANUMを比較してください。
CHKCHARADATA /// CHKCHARADATA str filename\n\ndatフォルダ内の"chara_*.dat"で示されるファイル名のデータの情报を返します。\nRESULTにはロード可能な场合は0、何らかの理由により不可能な场合は非0が代入されます。\nまた、ロード可能な场合はRESULTS:0にセーブデータのメモを代入し、不可能な场合はその理由をRESULTS:0に代入します。
FIND_CHARADATA /// FIND_CHARADATA str filename\n\nLOADCHARAの対象となり得るファイルをdatフォルダの中から探索しファイル名(chara_*.datの*の部分)をRESULTSに代入します。\nRESULTにはヒット数（发見されたファイル数）が代入されます。\n引数はchara_*.datの*の部分を指定できます。\n例えばFIND_CHARADATA("*あなた*")であれば、chara_*あなた*.datを探し、chara_001あなた.datやchara_あなたABC.datがヒットします。\n引数を省略した场合、"*"を指定したことになりchara_*.datを探します。\nなお、chara_.dat(*が空文字列)はLOADCHARAで指定できないのでヒットしません。\nヒット数がRESULTSの要素数を超えた场合はエラーにはなりませんが超えた分のファイル名は代入されません。


;日期・时刻取得
GETTIME /// GETTIME\n\nパソコンの現在日时・时刻に関する情报をRESULT:0とRESULTS:0に代入します。\n現在日时が2009年3月28日13时5分23秒678ミリ秒であれば、RESULT:0には"20090328130523678"が代入されます。\nRESULTS:0には"2009年03月28日 13:05:23"が代入されます。\nRESULTS:0は主にセーブデータのコメントに使用することを想定しています。\n年月日について独自の表记をしたい场合はRESULT:0を分解して使用してください。\nなお、RESULT:0の精度は実行する环境にもよりますが、十数～数十ミリ秒程度です。\n（数ミリ秒しか経過していない场合、同じ值が帰ってくることがあります）\nパフォーマンスの测定を目的とする场合は注意してください。
GETMILLISECOND /// GETMILLISECOND\n\n西暦0001年1月1日からの経過时间をミリ秒単位で取得し、RESULT:0に代入します。\nそのまま加減算ができるので経過时间などを調べるにはGETTIMEよりも適しています。\nなお、RESULT:0の精度は実行する环境にもよりますが、十数～数十ミリ秒程度です。\n（数ミリ秒しか経過していない场合、同じ值が帰ってくることがあります）\nパフォーマンスの测定を目的とする场合は注意してください。
GETSECOND /// GETSECOND\n\n西暦0001年1月1日からの経過时间を秒単位で取得し、RESULT:0に代入します。\nそのまま加減算ができるので経過时间などを調べるにはGETTIMEよりも適しています。 


;入力・ウェイト
FORCEWAIT /// FORCEWAIT\n\n右クリック、マクロのスキップでスキップできないWAIT命令です。\nこの命令に達した时点でこれらのスキップ状态は解除されます。
INPUT,INPUTS /// INPUT {<数值>}\nINPUTS {<文字列>}\n\neramakerと同様の命令ですが、引数により空文字列を入力された场合のデフォルト入力值を设定することができます。\n引数を省略し空文字列を入力した场合、从来と同様にINPUTは再入力、INPUTSはRESULTSに空文字列が代入され次の处理へ進みます。
TINPUT,TINPUTS /// TINPUT <数值>, <数值>{, <数值>, <文字列>}\nTINPUTS <数值>, <文字列式>{, <数值>, <文字列>}\n\n制限时间のある入力受付命令です。 1番目の引数は制限时间(ms)ですが、100msより细かい值を设定しても正確な动作はできません。\n2番目の引数は时间切れ时のデフォルトのリターン值になります\n3番目の引数は残り时间を表示するかで0なら非表示、他は表示となります。省略した场合は1（表示）です。\n4番目の引数は时间切れ时に表示される文字列です。空文字列の场合はタイマー表示を消去して次の处理へ移ります。\nなお、4番目の引数を设定した场合、3番目の引数は省略できません。\nまたTINPUTSにおいて、INPUTS同様にマクロ式を用いることができます。\n文字列として()を使用する场合、を用いてエスケープしてください。
TWAIT /// TWAIT <数值>, <数值>\n\n第一引数が制限时间、第二引数が入力受付フラグです。\n制限时间経過するまで动作を停止します\n実際の挙动は入力受付フラグの指定によって変化します\n\n    入力受付フラグ = 0：入力を受け付け、入力がなされると制限时间前でも次に進みます\n    入力受付フラグ ≠ 0：入力を受け付けません（制限时间まで强制的に待たせることができます） 
ONEINPUT,ONEINPUTS /// ONEINPUT {<数值>}\nONEINPUTS {<文字列>}\n\n以下、私家改造版更新履历より、\n\n一文字限定入力自动处理命令ONEINPUT、ONEINPUTS实装\n　书式：ONEINPUT or ONEINPUTS\n　内容：一文字のみの入力を受け付ける、入力すると自动的に次の处理に移る\n\nペースト等を用いて複数桁の数字（複数の文字）を一度に贴りつけた场合、最初の桁（文字）のみが入力されたものとして处理されます。\nINPUTやINPUTS同様、引数により空文字列を入力された场合のデフォルト入力值を设定することができます。\nただし、ONEINPUTで負の值を指定した场合や、ONEINPUTSで空文字列を指定した场合は、引数は无效となり、引数なしの场合と同じ挙动になります。\nまた、複数桁の数字（複数の文字）を引数とした场合、最初の桁（文字）のみがデフォルト入力值となります。\n引数を省略し空文字列を入力した场合、通常と同様にONEINPUTは再入力、ONEINPUTSはRESULTSに空文字列が代入され次の处理へ進みます。\nONEINPUTSの场合、空文字列のままEnterを押しても空文字列を入力したとみなされます。\nなお、これらの命令を利用した场合にはEmueraのCONFIG设定において电子琴マクロを使用する设定になっていても、\nうまく働かない現象が起こりますがそれは仕様です。\nまたONEINPUTSにおいて、INPUTS同様にマクロ式を用いることができます。\n文字列として()を使用する场合、を用いてエスケープしてください。
TONEINPUT,TONEINPUTS /// TONEINPUT <数值>, <数值>{, <数值>, <文字列>}\nTONEINPUTS <数值>, <文字列式>{, <数值>, <文字列>}\n\n引数はそれぞれTINPUT、TINPUTSと同じです。\nそれぞれONEINPUTとTINPUT、ONEINPUTSとTINPUTSの性質を併せ持つ入力受付命令です。\nこれらの命令を利用した场合にはEmueraのCONFIG设定において电子琴マクロを使用する设定になっていても、\nうまく働かない現象が起こりますがそれは仕様です。\nまたTONEINPUTSにおいて、INPUTS同様にマクロ式を用いることができます。\n文字列として()を使用する场合、を用いてエスケープしてください。
WAITANYKEY /// WAITANYKEY\n\nいずれかのキー入力、またはマウスのクリックを待つWAIT命令です。\nWAITのONEINPUT版ともいえます。 


;ループ・分岐構文
FOR,NEXT /// FOR <数值型変数>, <数式>, <数式>{, <数式>}\nNEXT\n\nFOR～NEXTはREPEAT～RENDの机能强化版です。\n第１引数はカウントに使用される変数を表します（REPEATでは常にCOUNT:0）。\n第２引数は変数に最初に代入される值を表します（REPEATでは常に0）。\n第３引数はループが終了される值を表します（REPEATで设定可能な值）。\n第４引数はループごとに加算される值を表します（REPEATでは常に1）。\n\n　　FOR COUNT, 0, X\n　　　　～～\n　　NEXT\n　　REPEAT X\n　　　　～～\n　　REND\n\n上の二つはほぼ同じ动作をします。\nともにX回の繰り返しを行う構文で、ループの途中でCONTINUEやBREAKを使用できます。\n异なる点はカウント用の変数を指定できることと、开始值とステップを変更できることです。\nまた、FOR～NEXTは入れ子にすることができます。\n\n　　FOR Y, 0, 100\n　　　　FOR X, 0, 100\n　　　　　　～～\n　　　　NEXT\n　　NEXT\n\n第１引数である<変数名>に指定できる変数は数值型の変数のみです。キャラクタ変数も使えません。\n第４引数である<ステップ>は省略可能です。省略した场合、1です。\n<ステップ>が正の值のとき、繰り返しのたびに<変数名>の変数に<ステップ>が加算され、第３引数<終了值>を超えたときにループが終了します。\n<ステップ>が負の值のときは、<変数名>の変数が<終了值>より小さくなったときにループが終了します。\n<ステップ>が0であれば无限ループになります。BREAK文が実行されるまで永久に繰り返します。\n各值はループの开始と同时に固定され、ループの途中で変数が変化しても影響を受けません。\n以下の２つは同じ結果になります。\n\n　　;１\n　　X = 10\n　　FOR COUNT:X, 0, X, X/10\n　　　　X = 10000\n　　NEXT\n　　;２\n　　FOR COUNT:10, 0, 10, 10/10\n　　　　X = 10000\n　　NEXT\n\nなお、GOTO等の命令で直接FOR～NEXT内に入った场合、REPEAT～RENDと同様にNEXTの直前まで通常通り実行し、その后NEXTを无视して次の行から处理を続行します。
WHILE,WEND /// WHILE <数式>\nWEND\n\nREPEAT～RENDやFOR～NEXTのような繰り返し構文の一种です。\nWHILEの<数式>が0以外である限りループを繰り返します。\n常に満たし続ける条件を与えると、BREAKで抜けるようになっていない限り无限ループになります\nあまりにループ处理が长いとEmueraが文句を言う场合があります\nなお、GOTO等の命令で直接WHILE～WEND内に入った场合、通常どおりWENDに到達した时点でWHILEへループし、条件を判定します。
DO,LOOP /// DO\nLOOP <数式>\n\nREPEAT～RENDやFOR～NEXTのような繰り返し構文の一种です。\nCのdo～while、VBのdo～loop while構文と同様、LOOPの<数式>が0以外である限り実行をループを繰り返します。\nWHILE～WENDと异なり最低でも1回は実行されることが特徴です。\nなお、DO～LOOP内のCONTINUEした场合にはLOOPの条件を満たしていなければそのままLOOPを抜けます。CONTINUEしてもDO文に戻るとは限らないことに注意してください。\nまた、GOTO等の命令で直接DO～LOOP内に入った场合、通常どおりLOOPに到達した时点で条件を判定し、<数式>が0以外ならDOへループします。
SELECTCASE,CASE,CASEELSE,ENDSELECT /// SELECTCASE <式>\nCASE <CASE条件式>(, <CASE条件式>, <CASE条件式> ……)\nCASEELSE\nENDSELECT\n\nSELECTCASE X\n　　CASE 1\n　　　　PRINTL Xは1です。\n　　CASE 3\n　　　　PRINTL Xは3です。\n　　CASEELSE\n　　　　PRINTL Xは1でも3でもありません。\nENDSELECT\n\nこのスクリプトはXの值によって分岐します。\nSELECTCASE文が実行された时、Xが1であれば"CASE 1"の行に飛び、次のCASEまたはCASEELSEまでの行を実行します。\n同様にXが3であれば"CASE 3"に飛びます。\nXの值に対応するCASE文がない时、CASEELSE文があればそこに飛びます。なければENDSELECTに飛びます。\nCなどのswitch文と异なり、1つのCASEから次のCASEに流れ落ちることはありません。\nまた、BREAK文でENDSELECTに飛ぶことはできません。\nなお、GOTO等の命令で直接SELECTCASE～CASE～CASEELSE～ENDSELECT内に入った场合、IF～ELSEIF～ELSE～ENDIFと同様に\nCASE、CASEELSE、ENDSELECTの直前まで通常通り実行したあとに、ENDSELECTの次の行へ飛び处理を続行します。\n\n以下、详细はEmuera Wiki参照のこと


;乱数制御
RANDOMIZE,DUMPRAND,INITRAND /// RANDOMIZE <数式>\nDUMPRAND\nINITRAND\n\nRAND:Xで得られる乱数を制御するための命令です。\n\nRANDOMIZE命令は指定した值で乱数を初期化します。\n同じ值で初期化したならば、RANDは必ず同じ結果を返します。\n\nDUMPRANDは現在の乱数の状态をRANDDATA変数に保存します。\nINITRANDはRANDDATA変数に保存したデータを読み出します。\nDUMPRANDを行う前にINITRANDを行ってしまわないように注意してください。\nRANDDATA変数の中身が不適当な场合、RANDが正常に动作しなくなります。\n\nPRINTFORML {RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}\nRANDOMIZE 23478612\nPRINTFORML {RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}\nRANDOMIZE 23478612\nPRINTFORML {RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}\nDUMPRAND\nPRINTFORML {RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}\nINITRAND\nPRINTFORML {RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}\nINITRAND\nPRINTFORML {RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}\n\n;結果\n92539/49469/48337/15839/48368/1604\n34536/91889/81167/22434/87922/95565\n34536/91889/81167/22434/87922/95565\n68286/10690/68868/82610/90769/60789\n68286/10690/68868/82610/90769/60789\n68286/10690/68868/82610/90769/60789


;デバッグ补助・システムフロー制御
BEGIN /// BEGIN <キーワード>\n\nBEGINはeramakerから存在する命令ですが、キーワードとして新しくFIRSTとTITLEが追加されました。\nBEGIN FIRSTはタイトル画面で"[0]最初からはじめる"を选择した时と同じ效果で、イベント関数@EVENTFIRSTが実行されます。\nBEGIN TITLEはタイトル画面に戻ります。\nどちらも変数の初期化などは行いませんので適宜RESETDATA命令を実行してください。
CALLTRAIN /// CALLTRAIN <コマンド数>\n\n连続コマンド実行命令です。\nあらかじめSELECTCOM:(1～)にコマンド番号を代入しておき、実行するコマンドの数を引数にして実行します。\n\n　　SELECTCOM:1 = XXX\n　　SELECTCOM:2 = YYY\n　　　　　・\n　　　　　・\n　　　　　・\n　　SELECTCOM:N = ZZZ\n\n　　CALLTRAIN (设定したコマンドの数)\n\n通常のコマンド実行と同様にSHOW_STATUSやSHOW_USERCOMも呼び出しますが、TRAINコマンド、USERCOMの表示はされません。\nどうしてもUSERCOMの表示をしたい场合はNOSKIP～ENDNOSKIPを使うと良いでしょう。\nCALLTRAINによる自动実行が終了后、システム関数@CALLTRAINENDが呼び出されます。\nただし、@CALLTRAINENDはイベント関数ではないため多重定義できないことに注意してください。\nなお、コマンドの指定に使うコマンド番号は、ゲーム中の值でなく、TRAIN.CSVで指定した值になります
DOTRAIN /// DOTRAIN <数式>\n\n强制的にTRAINを行う命令です。\n@EVENTTRAIN、@SHOW_STATUS、@SHOW_USERCOM、@USERCOM、@EVENTCOMEND及びそこから呼び出された関数の中でのみ使用可能です。\n引数で指定する番号はtrain.csvで定義した番号に対応しています。\n动作はコマンドが选择された场合と同じで、UP、DOWNなどの変数を初期化し、SELECTCOMに引数を代入し、@EVENTCOMが呼ばれ、@COM{SELECTCOM}が呼ばれ……という流れになります。\n\n引数が0未満であるか、TRAINNAMEの要素数以上の值であればエラーになりますが、それ以外のチェックは行われません。\n引数がtrain.csvで定義されていない数字でも强制的に実行しようとします。\nまた、@COM_ABLEを呼び出さず、强制的に実行されます。\n必要であればDOTRAINの前に以下のようなチェックを行ってください。\n\nSIF ( X < 0 || X >= VARSIZE("TRAINNAME") || TRAINNAME:X == "" )\n　　RETURN\nRESULT = 1\nTRYCALLFORM COM_ABLE{X}\nSIF RESULT == 0\n　　RETURN\nDOTRAIN X\n\n逆にDOTRAINを用いてTRAINのコマンドを独自に实装することもできます。\n例えばtrain.csvを空にしておき、@SHOW_USERCOMで独自に表示し、@USERCOMでDOTRAINを行います。\nあるいはtrain.csvを空にする代わりに全ての@COM_ABLEが0を返すようにしてもよいでしょう。\n@COM_ABLEを変更する代わりに、全ての@COM_ABLEを削除し、_replace.csvの"COM_ABLE初期值"を0にする方法もあります。\n\nなお、CALLTRAINの处理の途中でDOTRAINが行われた场合、CALLTRAINの残りは无效になります。
THROW /// THROW <FORM構文>\n\n强制的にエラーとし、引数に与えた文字列でエラー表示を行う命令です。 


;CALL・JUMP・GOTO系
TRYJUMP,TRYCALL,TRYGOTO /// TRYJUMP <文字列> (, 引数1, 引数2……)\nTRYCALL <文字列> (, 引数1, 引数2……)\nTRYGOTO <文字列>\n\nJUMP、CALL、GOTOと同じですが、指定した関数が存在しなくともエラーになりません。\n指定した関数が存在しない场合は何もしません。\nTRYJUMPとTRYCALLは引数を指定できます。詳しくは関数の「自作関数における引数指定」の項を参照してください。\nなお、TRYGOTOで直接IF～ELSEIF～ELSE～ENDIF内に入った场合、ELSEIF、ELSE、ENDIFの直前まで通常通り実行したあとに、ENDIFの次の行へ飛び处理を続行します。\nまた直接REPEAT～REND内に入った场合、RENDの直前まで通常通り実行し、その后RENDを无视して次の行から处理を続行します。\nこれらの处理はGOTOや他のGOTO系命令と同様の处理です。
JUMPFORM,CALLFORM,GOTOFORM /// JUMPFORM <书式付文字列> (, 引数1, 引数2……)\nCALLFORM <书式付文字列> (, 引数1, 引数2……)\nGOTOFORM <书式付文字列>\n\nJUMP、CALL、GOTOと同じですが、PRINTFORMなどと同じ形式で関数名を指定できます。
TRYJUMPFORM,TRYCALLFORM,TRYGOTOFORM /// TRYJUMPFORM <书式付文字列> (, 引数1, 引数2……)\nTRYCALLFORM <书式付文字列> (, 引数1, 引数2……)\nTRYGOTOFORM <书式付文字列>\n\nJUMP、CALL、GOTOと同じですが、PRINTFORMなどと同じ形式で関数名を指定でき、関数が存在しなくてもエラーになりません。\nTRYJUMPFORMとTRYCALLFORMは引数を指定できます。詳しくは関数の「自作関数における引数指定」の項を参照してください。\nなお、TRYGOTOFORMで直接ループ・分岐構文内に入った场合については「TRYGOTO」やこのページの「ループ・分岐構文」「TRYC系」の項を参照してください。
CALLF,CALLFORMF /// CALLF <文字列> (, 引数1, 引数2……)\nCALLFORMF <书式付文字列> (, 引数1, 引数2……)\n\n以下、私家改造版更新履历より、\n\n式中関数を返り值无视で呼び出す命令CALLF、CALLFORMF实装\n　书式：CALLF 関数名, 引数1, ....\n　　　　（式中関数ですが、普通の関数の引数书式で呼び出してください）\n　内容：式中関数を通常の関数扱いで呼び出す、返り值は破棄される\n　　疑似SETTERを作りたくてやった、今は反省している\n\n当然だがRESULTやRESULTSは呼んだ式中関数内で操作していない限り、変化しない。
CALLEVENT /// CALLEVENT <文字列>\n\nイベント関数をイベント関数として呼び出します。\n引数を与えることはできません。\nまたイベント関数中やイベント関数から呼び出された関数中で使用することもできません。 


;CALL・JUMP・GOTO系2 (TRYC-CATCH-ENDCATCH)
TRYCJUMP,TRYCCALL,TRYCGOTO,TRYCJUMPFORM,TRYCCALLFORM,TRYCGOTOFORM,CATCH,ENDCATCH /// TRYCJUMP <文字列> (, 引数1, 引数2……)\nTRYCCALL <文字列> (, 引数1, 引数2……)\nTRYCGOTO <文字列>\nTRYCJUMPFORM <书式付文字列> (, 引数1, 引数2……)\nTRYCCALLFORM <书式付文字列> (, 引数1, 引数2……)\nTRYCGOTOFORM <书式付文字列>\nCATCH\nENDCATCH\n\n扩张书式：TRYC系関数呼び出し～CATCH～ENDCATCH\n　(TRYC系はTRY系関数と同様の関数系が用意されてます)\n内容：TRYC系の関数呼び出し时に関数が見つからなかった场合の挙动を制御\n　文法としてはIF～ELSE～ENDIFと同様になりました（違いは関数があった场合の处理がなくてもよいこと）\nそのため、GOTO等の命令で直接TRYC系～CATCH～ENDCATCH内に入った场合、IF～ELSEIF～ELSE～ENDIFと同様に\nCATCH、ENDCATCHの直前まで通常通り実行したあとに、ENDCATCHの次の行へ飛び处理を続行します。\nまた、TRYCGOTO・TRYCGOTOFORMで直接ループ・分岐構文内に入った场合については「TRYGOTO」やこのページの「ループ・分岐構文」の項を参照してください。\n\n　　TRYCCALL UNKNOWN_FUNC ;存在しない関数\n　　　　関数があったとき、関数处理后に行う处理（あれば、なければ省略して直CATCHでOK）\n　　CATCH\n　　　　関数がなかったときに行う处理\n　　ENDCATCH\n\nなお、入れ子可能です。
TRYCALLLIST,TRYJUMPLIST,TRYGOTOLIST,FUNC,ENDFUNC /// TRYCALLLIST\nTRYJUMPLIST\nTRYGOTOLIST\nFUNC <文字列> (, 引数1, 引数2……)\nENDFUNC\n\n複数の関数（ラベル）を指定し、最初に見つかった関数（のみ）を呼び出すための構文です。\nTRYLIST系～ENDFUNC内に上记の文法以外の记述をすることはできません。\nなお、TRYGOTOLISTで直接ループ・分岐構文内に入った场合については「TRYGOTO」やこのページの「ループ・分岐構文」「TRYC系」の項を参照してください。\n以下のように使用します。\n\nTRYCALLLIST\n　　FUNC 関数1\n　　FUNC 関数2\nENDFUNC\n\nFUNCで指定された関数の呼び出しを顺に試み、成功すれば呼び出した后ENDFUNCへ、失敗すれば次の行のFUNC（又はENDFUNC）へ移动します。\nこれは以下のスクリプトと同等です。\n\nTRYCCALL 関数1\nCATCH\n　　TRYCCALL 関数2\n　　CATCH\n　　ENDCATCH\nENDCATCH


;RETURN系
RETURN /// RETURN <数式>(, <数式>, <数式>, ...)\n\neramakerからある命令ですが、返り值に定数でない変数や数式も指定できるようになりました。\nまた、複数の返り值に対応しています。\n複数の返り值を指定した场合、先头からRESULT:0、RESULT:1...という风に代入されます。
RETURNFORM /// RETURNFORM <书式付文字列>(, <书式付文字列>, <书式付文字列>, ...)\n\nRETURNの亜种です。\n引数に指定された书式付文字列を数式として解析し、RETURNを行います。\n例えば、以下のようなことができます。\n\n　　A = 100\n　　CALL TEST\n　　PRINTFORMW RESULT == {RESULT}\n\n@TEST\n　　STR = A * 10\n　　RETURNFORM %STR%\n\nRETURNと异なり、%は剰余演算子ではなく文字列式の开始とみなされるので注意してください。\n\n;OK。Aの下２ケタを返す。\n　　RETURN A % 100\n\n;エラー。%以降を文字列式として読もうとするので。\n　　RETURNFORM A % 100\n\nまた、複数の返り值に対応しています。\n複数の返り值を指定した场合、先头からRESULT:0、RESULT:1...という风に代入されます。
RETURNF /// RETURNF <式>\n\n#FUNCTIONまたは#FUNCTIONS属性を持つ関数専用の命令です。\n详细はユーザー定義の式中関数を参照してください。\n複数の返り值には対応していません。 


;DEBUG系
DEBUGPRINT,DEBUGPRINTL,DEBUGPRINTFORM,DEBUGPRINTFORML /// DEBUGPRINT <文字列>\nDEBUGPRINTL <文字列>\nDEBUGPRINTFORM <书式付文字列>\nDEBUGPRINTFORML <书式付文字列>\n\nこれらはそれぞれPRINT命令やPRINTLと同様の动作をします。\n异なる点は出力先がメインコンソールではなくデバッグコンソールである点です。\nまた、SKIPDISP命令の影響を受けず、nを使用することもできません。
DEBUGCLEAR /// DEBUGCLEAR\n\nデバッグコンソールのPRINT内容を全て削除します。
ASSERT /// ASSERT <数式>\n\n引数が真(非0)のとき、何もしません。\n引数が偽(0)の时、エラーを出力してスクリプトの実行を停止します。 


